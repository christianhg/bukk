import test from 'ava'

import B from '../src/bukk'
import kind from '../src/kind'

test('should export B.add', t => {
  t.is(kind(B.add), 'Function')
})

test('should export B.all', t => {
  t.is(kind(B.all), 'Function')
})

test('should export B.and', t => {
  t.is(kind(B.and), 'Function')
})

test('should export B.any', t => {
  t.is(kind(B.any), 'Function')
})

test('should export B.append', t => {
  t.is(kind(B.append), 'Function')
})

test('should export B.compose', t => {
  t.is(kind(B.compose), 'Function')
})

test('should export B.curry', t => {
  t.is(kind(B.curry), 'Function')
})

test('should export B.dec', t => {
  t.is(kind(B.dec), 'Function')
})

test('should export B.divide', t => {
  t.is(kind(B.divide), 'Function')
})

test('should export B.equals', t => {
  t.is(kind(B.equals), 'Function')
})

test('should export B.filter', t => {
  t.is(kind(B.filter), 'Function')
})

test('should export B.find', t => {
  t.is(kind(B.find), 'Function')
})

test('should export B.flatten', t => {
  t.is(kind(B.flatten), 'Function')
})

test('should export B.gt', t => {
  t.is(kind(B.gt), 'Function')
})

test('should export B.gte', t => {
  t.is(kind(B.gte), 'Function')
})

test('should export B.head', t => {
  t.is(kind(B.head), 'Function')
})

test('should export B.inc', t => {
  t.is(kind(B.inc), 'Function')
})

test('should export B.init', t => {
  t.is(kind(B.init), 'Function')
})

test('should export B.kind', t => {
  t.is(kind(B.kind), 'Function')
})

test('should export B.last', t => {
  t.is(kind(B.last), 'Function')
})

test('should export B.lt', t => {
  t.is(kind(B.lt), 'Function')
})

test('should export B.lte', t => {
  t.is(kind(B.lte), 'Function')
})

test('should export B.map', t => {
  t.is(kind(B.map), 'Function')
})

test('should export B.max', t => {
  t.is(kind(B.max), 'Function')
})

test('should export B.min', t => {
  t.is(kind(B.min), 'Function')
})

test('should export B.multiply', t => {
  t.is(kind(B.multiply), 'Function')
})

test('should export B.none', t => {
  t.is(kind(B.none), 'Function')
})

test('should export B.or', t => {
  t.is(kind(B.or), 'Function')
})

test('should export B.pipe', t => {
  t.is(kind(B.pipe), 'Function')
})

test('should export B.prepend', t => {
  t.is(kind(B.prepend), 'Function')
})

test('should export B.prop', t => {
  t.is(kind(B.prop), 'Function')
})

test('should export B.range', t => {
  t.is(kind(B.range), 'Function')
})

test('should export B.reject', t => {
  t.is(kind(B.reject), 'Function')
})

test('should export B.reduce', t => {
  t.is(kind(B.reduce), 'Function')
})

test('should export B.slice', t => {
  t.is(kind(B.slice), 'Function')
})

test('should export B.subtract', t => {
  t.is(kind(B.subtract), 'Function')
})

test('should export B.tail', t => {
  t.is(kind(B.tail), 'Function')
})

test('should export B.take', t => {
  t.is(kind(B.take), 'Function')
})

test('should export B.trim', t => {
  t.is(kind(B.trim), 'Function')
})

test('should export B.type', t => {
  t.is(kind(B.type), 'Function')
})

test('should export B.zip', t => {
  t.is(kind(B.zip), 'Function')
})
